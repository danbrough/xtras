package = org.danbrough.ssh2.cinterops
headers = libssh2.h  libssh2_publickey.h  libssh2_sftp.h
linkerOpts = -lssh2

### XTRAS: generated paths from the cinteropsTargetWriter

compilerOpts.macos_arm64 =  -I/Users/dan/workspace/xtras/xtras/libs/ssh2/macosArm64/1.11.0/include
linkerOpts.macos_arm64 = -L/Users/dan/workspace/xtras/xtras/libs/ssh2/macosArm64/1.11.0/lib
libraryPaths.macos_arm64 =  /Users/dan/workspace/xtras/xtras/libs/ssh2/macosArm64/1.11.0/lib

compilerOpts.macos_x64 =  -I/Users/dan/workspace/xtras/xtras/libs/ssh2/macosX64/1.11.0/include
linkerOpts.macos_x64 = -L/Users/dan/workspace/xtras/xtras/libs/ssh2/macosX64/1.11.0/lib
libraryPaths.macos_x64 =  /Users/dan/workspace/xtras/xtras/libs/ssh2/macosX64/1.11.0/lib

---
  #include<libssh2.h>

static int waitsocket(libssh2_socket_t socket_fd, LIBSSH2_SESSION *session)
{
    struct timeval timeout;
    int rc;
    fd_set fd;
    fd_set *writefd = NULL;
    fd_set *readfd = NULL;
    int dir;

    timeout.tv_sec = 10;
    timeout.tv_usec = 0;

    FD_ZERO(&fd);

    FD_SET(socket_fd, &fd);

    /* now make sure we wait in the correct direction */
    dir = libssh2_session_block_directions(session);

    if(dir & LIBSSH2_SESSION_BLOCK_INBOUND)
        readfd = &fd;

    if(dir & LIBSSH2_SESSION_BLOCK_OUTBOUND)
        writefd = &fd;

    rc = select((int)(socket_fd + 1), readfd, writefd, NULL, &timeout);

    return rc;
}
